
Assignment 3 “Raytracer”

Jordi Vermeulen (3835634)
Martijn Koenis (3770214) 
 
Application
We have chosen the raytracer we created together with Remco Kuijper for the course Advanced Graphics (2014/2015). The raytracer can simulate diffuse, specular, glossy and refractive. It uses an octree for each object in a scene to store the triangles of that object. The raytracer works on the CPU. The raytracer also has some sort next event estimation but this feature is working incorrectly. The raytracer is already parallelised.

Improvement process
In order to determine the main bottlenecks of the application we used the Visual Studio 2013 profiler (unless otherwise mentioned all further profiles are done using this profiler) on the application. This Where the results from the profiler.  (INSERT DATA) 

You can clearly see that the intersection tests with both bounding boxes and triangles are taking up most of the time (71%) so this will be the main focus of our first optimisation step. 
Firstly we wanted to fix the next event estimation. Although this will make the application run slower the result will converge to the correct solution quicker hopefully giving an overall speed increase if for the same quality of result. We also fixed some memory leaks and bugs in the application. (INSERT DATA 82bfbcd2ea0b3e4fcdbe4c379f2c00e5ce931c4c) + profile

From the profile above one can see that the triangle intersections still take up allot of time. In order to reduce this we used AVX to do 4 double calculations at once. We also restructured to octree to now have internal nodes and leaf node which quickens the querying time. INSERT DATA 770c26d0dd433d79cfa68dc214e522dc96d16572
In order to speed things up even more we wanted to use floats instead of doubles. In this way we can do 8 triangle intersections at the same time instead of 4. Also floats are generally assumed to be faster than doubles. This step lead to (INTSERT DATA 60cb1890f6d851fff903566239484c2e0de1da86)

We then wanted to optimize the SampleLight function because it now uses a significant portion of the time. In order to do this we found a better way to interpolate triangles. The new method was faster because more things could be pre-computed. We also changed the std::vector that was used to store all light triangles into an array. (INSERT DATA 276b1dbf6d86061429236a843051ac33adc1ccfb)

On advice of our teacher we also decided to use a Bounding Volume Hierarchy instead of an octree. We created this in parallel with the earlier mentioned steps but at this point we merged them and did not go back to the octree version. We wanted to use a BVH because it could result in less bounding box and triangle intersection and thus speed up the program significantly. Because we did not succeed in including any online fast BVH we made our own BVH. We used a Surface Area Heuristic in order to find the best of 8 splitting planes or no split at all. INSERT DATA f3c955932845b774c1e9d6ece0a5188d7a83c310
