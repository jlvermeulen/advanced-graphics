
Assignment 3 “Raytracer”

Jordi Vermeulen (3835634)
Martijn Koenis (3770214) 
 
Application
We have chosen the raytracer we created together with Remco Kuijper for the course Advanced Graphics (2014/2015). The raytracer can simulate diffuse, specular, glossy and refractive. It uses an octree for each object in a scene to store the triangles of that object. The raytracer works on the CPU. The raytracer also has some sort next event estimation but this feature is working incorrectly. The raytracer is already parallelised.
Improvement process
In order to determine the main bottlenecks of the application we used the Visual Studio 2013 profiler (unless otherwise mentioned all further profiles are done using this profiler) on the application. This Where the results from the profiler.  (INSERT DATA) 
You can clearly see that the intersection tests with both bounding boxes and triangles are taking up most of the time (71%) so this will be the main focus of our first optimisation step. 
Firstly we wanted to fix the next event estimation. Although this will make the application run slower the result will converge to the correct solution quicker hopefully giving an overall speed increase if for the same quality of result. We also fixed some memory leaks and bugs in the application. (INSERT DATA 82bfbcd2ea0b3e4fcdbe4c379f2c00e5ce931c4c) When we run the profiler again we see: 
From the profile above one can see that the triangle intersections still take up allot of time. In order to reduce this we used AVX to do 4 double calculations at once. We also restructured to octree to now have internal nodes and leaf node which quickens the querying time. INSERT DATA 770c26d0dd433d79cfa68dc214e522dc96d16572 When we run the profiler again we see:
 
In this profiling result the triangle intersections are now done in OctreeLeaf::Query. As you can see this is still the bottleneck of the application. In order to speed things up even more we wanted to use floats instead of doubles. In this way we can do 8 triangle intersections at the same time instead of 4. Also floats are generally assumed to be faster than doubles. This step lead to (INTSERT DATA 60cb1890f6d851fff903566239484c2e0de1da86) When we run the profiler again we see:  
We then wanted to optimize the SampleLight function because it now uses a significant portion of the time (27%). In order to do this we found a better way to interpolate triangles. The new method was faster because more things could be pre-computed. We also changed the std::vector that was used to store all light triangles into an array. (INSERT DATA 276b1dbf6d86061429236a843051ac33adc1ccfb) When we run the profiler again we see:  
As you can see in the profiler results above the triangle and bounding box intersections still take most of the cpu usage. On advice of our teacher we also decided to use a Bounding Volume Hierarchy instead of an octree. We created this in parallel with the earlier mentioned steps but at this point we merged them and did not go back to the octree version. We wanted to use a BVH because it could result in less bounding box and triangle intersection and thus speed up the program significantly. Because we did not succeed in including any online fast BVH we made our own BVH. We used a Surface Area Heuristic in order to find the best of 8 splitting planes or no split at all. INSERT DATA f3c955932845b774c1e9d6ece0a5188d7a83c310 When we run the profiler again we see:  
From this profiler result we concluded that the bounding box intersection still takes quite some time (22%). In order to reduce this we want to compact the BVH such that the nodes have 8 children (so we compact three layers into one). This will allow us to use AVX to do 8 boundingbox intersection tests at once and thus should reduce the time taken by boundingbox intersections.
 
List of things we tried but did not help:
-	Bounding spheres
-	One tree per scene
Work distribution
Similar to the previous assignment most of the work was done while working together at the university. At home we worked in parallel on different attempts, approaches and/or targets.  

